```c++
#include<iostream>
#include<string>
#include<fstream>
#include<stack>
#include<sstream>
#include<vector>
#pragma warning (disable:4996)
using namespace std;

bool is_number(string s);

typedef struct Token
{
	string type, content;//type是类型，content是字符串
	int number;//number是序号
};

Token token[10000];
static int ptr = 0;//token下标
stack<string> ss;

typedef struct Node
{
	int name;
	string operate;
	string main_tag;
	vector <string> other_tags;
	vector <int> fathers;
	vector <int> sons;
}Node;

typedef struct Four_exp
{
	string syb;
	string exp1;
	string exp2;
	string res;
}Four_exp;

typedef struct nd
{
	vector<Four_exp> blk;
	nd* next;
}nd;
vector<Four_exp> block;
class DAG_graph
{
	vector <Node> points;
public:
	void insert(Node point);
	int define(string s);
	void add(string main_tag, string tag);
	int find_main(string main_tag);
	int find_others(string other_tag);
	void find_and_delete_other(string other_tag, int name);
	int find_exp1(string s1, string s2, string s3);
	int find_exp2(string s1, string s2);
	bool is_empty() { return this->points.empty(); }
	void insert_num(Four_exp a);
	void fuzhi(Four_exp a);
	void changzhi(Four_exp a);
	void qita(Four_exp a);
	void print();
	int get_size() { return points.size(); }
	void operate(Four_exp a);
	void clear() { points.clear(); }
};
void DAG_graph::insert(Node point)
{
	point.name = this->points.size() + 1;
	points.push_back(point);
}
int DAG_graph::define(string s)
{
	for (int i = 0; i < this->points.size(); i++)
	{
		if (this->points[i].main_tag == s)
			return -1;
		else
		{
			for (int j = 0; j < this->points[i].other_tags.size(); j++)
				if (s == this->points[i].other_tags[j])
					return -2;
		}
	}
	Node point;
	point.name = this->points.size();
	point.main_tag = s;
	this->points.push_back(point);
	return point.name;
}
void DAG_graph::add(string main_tag, string other_tag)
{
	for (int i = 0; i < this->points.size(); i++)
		if (points[i].main_tag == main_tag)
		{
			points[i].other_tags.push_back(other_tag);
			if (main_tag[0] == 't' && other_tag[0] != 't')
			{
				points[i].other_tags.pop_back();
				points[i].other_tags.push_back(main_tag);
				points[i].main_tag = other_tag;
			}
		}
}
int DAG_graph::find_main(string main_tag)
{
	for (int i = 0; i < this->points.size(); i++)
		if (points[i].main_tag == main_tag)
			return i;
	return -1;
}
int DAG_graph::find_others(string other_tag)
{
	for (int i = 0; i < points.size(); i++)
		for (int j = 0; j < points[i].other_tags.size(); j++)
			if (other_tag == points[i].other_tags[j])
				return i;
	return -1;
}
void DAG_graph::find_and_delete_other(string other_tag, int name)
{
	for (int i = 0; i < this->points.size(); i++)
		for (int j = 0; j < this->points[i].other_tags.size(); j++)
			if (points[i].other_tags[j] == other_tag && i != name)
				points[i].other_tags.erase(points[i].other_tags.begin() + j);
}
int DAG_graph::find_exp1(string s1, string s2, string s3)
{
	int pos1 = find_main(s2);
	if (pos1 == -1)
		pos1 = find_others(s2);
	int pos2 = find_main(s3);
	if (pos2 == -1)
		pos2 = find_others(s3);
	for (int i = 0; i < this->points.size(); i++)
	{
		if (points[i].sons.size() == 2 && points[i].operate == s1 && ((points[i].sons[0] == pos1 && points[i].sons[1] == pos2) || (points[i].sons[0] == pos2 && points[i].sons[1] == pos1)))
			return i;
	}
	return -1;
}
int DAG_graph::find_exp2(string s1, string s2)
{
	int pos1 = find_main(s2);
	for (int i = 0; i < this->points.size(); i++)
	{
		if (points[i].sons.size() == 1 && points[i].operate == s1 && points[i].sons[0] == pos1)
			return i;
	}
	return -1;
}
void DAG_graph::insert_num(Four_exp a)
{
	double num1 = stof(a.exp1);
	double num2 = stof(a.exp2);
	double result;
	if (a.syb[0] == '+')
		result = num1 + num2;
	else if (a.syb[0] == '-')
		result = num1 - num2;
	else if (a.syb[0] == '*')
		result = num1 * num2;
	else if (a.syb[0] == '/')
		result = num1 / num2 * 1.0;
	else
		return;
	int pos = find_main(to_string(result));
	find_and_delete_other(a.res, pos);
	if (pos == -1)
	{
		Node n;
		vector<int> temp1;
		n.fathers = temp1;
		n.sons = temp1;
		vector<string> temp2;
		n.main_tag = to_string(result);
		n.operate = a.syb;
		temp2.push_back(a.res);
		n.other_tags = temp2;
		n.name = 0;
		insert(n);
	}
	else
	{
		add(to_string(result), a.res);
	}
}
void DAG_graph::fuzhi(Four_exp a)
{
	if (is_number(a.exp1))
	{
		if (find_main(a.exp1) == -1)
			define(a.exp1);
	}
	int name = find_main(a.exp1);
	add(a.exp1, a.res);
	find_and_delete_other(a.res, name);
}
void DAG_graph::changzhi(Four_exp a)
{
	double num1 = stof(a.exp1);
	double num2 = stof(a.exp2);
	double result;
	if (a.syb == "+")
		result = num1 + num2;
	else if (a.syb == "-")
		result = num1 - num2;
	else if (a.syb == "*")
		result = num1 * num2;
	else if (a.syb == "/")
		result = num1 / num2 * 1.0;
	else
	{
		define(a.exp1);
		define(a.exp2);
		qita(a);
		return;
	}
	string rslt = to_string(result);
	if (find_main(rslt) == -1)
		define(rslt);
	add(rslt, a.res);
	int name = find_main(rslt);
	find_and_delete_other(a.res, name);
}
void DAG_graph::qita(Four_exp a)
{
	if (a.exp2 == " ")
	{
		int pos = find_exp2(a.syb, a.exp1);
		if (pos != -1)
		{
			points[pos].other_tags.push_back(a.res);
		}
	}
	else
	{
		int pos = find_exp1(a.syb, a.exp1, a.exp2);
		if (pos != -1)
		{
			points[pos].other_tags.push_back(a.res);
		}
		else
		{
			int pos1 = find_main(a.exp1);
			if (pos1 == -1)
				pos1 = find_others(a.exp1);

			int pos2 = find_main(a.exp2);
			if (pos2 == -1)
				pos2 = find_others(a.exp2);
			int pos3 = define(a.res);
			if (pos3 == -1)
				pos3 = find_main(a.res);
			/*else if (pos3 == -2)
			{
				Node point;
				point.name = this->points.size();
				point.main_tag = a.res;
				this->points.push_back(point);
				pos3 = point.name;
				find_and_delete_other(a.res, pos3);
			}*/
			points[pos3].operate = a.syb;
			points[pos1].fathers.push_back(pos3);
			points[pos2].fathers.push_back(pos3);
			points[pos3].sons.push_back(pos1);
			points[pos3].sons.push_back(pos2);
		}
	}
}
void DAG_graph::print()
{
	block.clear();
	for (int i = 0; i < get_size(); i++)
	{
		if (points[i].sons.empty())
		{
			for (int j = 0; j < points[i].other_tags.size(); j++)
				if (points[i].other_tags[j][0] != 't')
				{
					Four_exp a;
					a.syb = "=";
					a.exp1 = points[i].main_tag;
					a.exp2 = " ";
					a.res = points[i].other_tags[j];
					block.push_back(a);
				}
		}
		else
		{
			if (points[i].sons.size() == 1)
			{
				Four_exp a;
				a.syb = points[i].operate;
				a.exp1 = points[points[i].sons[0]].main_tag;
				a.exp2 = " ";
				a.res = points[i].main_tag;
				block.push_back(a);
			}
			else
			{
				Four_exp a;
				a.syb = points[i].operate;
				a.exp1 = points[points[i].sons[0]].main_tag;
				a.exp2 = points[points[i].sons[1]].main_tag;
				a.res = points[i].main_tag;
				block.push_back(a);
			}
			for (int j = 0; j < points[i].other_tags.size(); j++)
				if (points[i].other_tags[j][0] != 't')
				{
					Four_exp a;
					a.syb = "=";
					a.exp1 = points[i].main_tag;
					a.exp2 = " ";
					a.res = points[i].other_tags[j];
					block.push_back(a);
				}
		}
	}
}
void DAG_graph::operate(Four_exp a)
{
	if (a.syb == "=")
		fuzhi(a);
	else
	{
		if (is_number(a.exp1) && is_number(a.exp2))
			changzhi(a);
		else
		{
			define(a.exp1);
			define(a.exp2);
			qita(a);
		}
	}
}

class jibenkuai
{
	nd* head = new nd;
	nd* q;
	nd* tail;
public:
	nd* get_head() { return head; }
	void create(Four_exp* p, int length);
};
void jibenkuai::create(Four_exp* p, int length)
{
	vector<int> duan;
	duan.push_back(0);
	q = head;
	for (int i = 0; i < length; i++)
	{
		if (p[i].res[0] == 'F')
		{
			duan.push_back(stoi(p[i].res.substr(1)));
			duan.push_back(i + 1);
		}
		if ((p[i].syb[0] >= 'a'&& p[i].syb[0] <= 'z'))
		{
			duan.push_back(i + 1);
		}
	}
	head->next = NULL;
	for (int i = 0; i < length; i++)
	{
		vector<int>::iterator result = find(duan.begin(), duan.end(), i);
		if (result == duan.end())
		{
			q->blk.push_back(p[i]);
		}
		else
		{
			q = new nd;
			//q->next = head->next;
			//head->next = q;
			q->blk.push_back(p[i]);
			tail = head;
			while (tail->next != NULL)
			{
				tail = tail->next;
			}
			tail->next = q;
			q->next = NULL;
		}
	}
}

class saomiaoqi
{
public:
	saomiaoqi() {}
	~saomiaoqi() {}
	int Change_State(int state, char ch);//识别器
	void Fenxi(int state_left);//分析器
	void kongzhi();//控制器
	int IsWord(char a);//判断是否为字母
	int IsNumber(char a);//判断是否为数字
protected:
	const char* KT[32] = { "main","break","case","char","const","continue","default","do","double","else","enum","extern","float","while","goto","if","int","long","register","return","short","signed","sizeof","static","struct","switch","typedef","union","usigned","void","volatile" ,"for" };//关键字
	char* IT[200] = { NULL };//标识符
	char* CT[200] = { NULL };//整数
	char* XT[200] = { NULL };//小数
	char* CTT[200] = { NULL };//字符
	char* ST[200] = { NULL };//字符串
	const char* PT[31] = { ">=","<=","==","=","<",">","+","-","*","/","(",")","[","]","{","}",",",";",".","_","++","--","+=","-=","*=","/=","&","&&","||","!","!=" };//界符
private:
	int state_left;//自动机之前的状态
	int state;//自动机的状态
	char st[10000];//识别出来的字符串
	int num;//st下标，用于判断双目运算符
	int key = 0;//语法出错标志
	int hangshu = 1;//行数
	int key1 = 0;//回车标志
	int key2 = 0;//是否需要输入";"的标志
	int key3 = 0;//注释判断
};

//判断是否为字母
int saomiaoqi::IsWord(char a)
{
	if (((a >= 'a') && (a <= 'z')) || ((a >= 'A') && (a <= 'Z')))
	{
		return 1;
	}
	else
	{
		return 0;
	}
}

//判断是否为数字
int saomiaoqi::IsNumber(char a)
{
	if ((a >= '0') && (a <= '9'))
	{
		return 1;
	}
	else
	{
		return 0;
	}
}

//识别器(有限制动机)
//自动机说明状态说明：
//1： 初始状态    2： 关键字/标识符
//3： 正整数      4： 小数点  
//5： 单引号      6： 没遇到引号的字符
//7： 字符        10：字符串
//11：界符        12: 小数
int saomiaoqi::Change_State(int state, char ch)
{
	if ((key3 != 0) || (ch == '/'))
	{
		if (state == 1)
			return 13;
		else if (state == 13)
		{
			return 14; key3 = 1;
		}
		else if (key3 == 1)
		{
			if (ch == '\n')
				cout << "注释缺少斜线" << endl;
		}
		else  key3 = 0;
	}
	else if ((ch == ' ') || (ch == '\t') || (ch == '\n'))
	{
		if (ch == '\n')
		{
			if (st[num - 1] == ';' || st[num - 1] == '{' || st[num - 1] == '}' || st[num - 1] == ')')
			{

			}
			else if (key1 == 1 || key2 == 1)
			{
				if (key1 == 1)
					key1 = 0;
				if (key2 == 1)
					key2 = 0;
			}
			else
			{
				cout << "第" << hangshu << "行没有';'" << endl;
			}
			hangshu++;
			key1 = 1;
		}
		if (state == 5)
			return 6;
		else if (state == 8 || state == 9)
			return 9;
		else return 0;
	}
	else if (IsWord(ch))
	{
		if (state == 1 || state == 2)
			return 2;
		else if (state == 5)
			return 6;
		else if (state == 8 || state == 9)
			return 9;
		else if (state == 11)
		{
			st[num] = '\0';
			Fenxi(state_left);
			num = 0;
			memset(st, 0, 10);
			return 2;
		}
		else
		{
			key = 1;
			st[num] = ch;
			st[num + 1] = '\0';
			Fenxi(state_left);
			num = 0;
			memset(st, 0, 10);
			return 2;
		}
	}
	else if (IsNumber(ch))
	{
		if (state == 1 || state == 3)
			return 3;
		else if (state == 4)
			return 12;
		else if (state == 12)
			return 12;
		else if (state == 2 && st[num - 1] != '.')
			return 2;
		else if (state == 5)
			return 6;
		else if (state == 8 || state == 9)
			return 9;
		else if (state == 11)
		{
			st[num] = '\0';
			Fenxi(state_left);
			num = 0;
			memset(st, 0, 10);
			return 3;
		}
		else
		{
			key = 1;
			st[num] = ch;
			st[num + 1] = '\0';
			Fenxi(state_left);
			num = 0;
			memset(st, 0, 10);
			return 3;
		}
	}
	else if (ch == '_')
	{
		if (state == 1 || state == 2)
			return 2;
		else if (state == 5)
			return 6;
		else if (state == 8 || state == 9)
			return 9;
		else if (state == 11)
		{
			st[num] = '\0';
			Fenxi(state_left);
			num = 0;
			memset(st, 0, 10);
			return 2;
		}
		else
		{
			key = 1;
			st[num] = ch;
			st[num + 1] = '\0';
			Fenxi(state_left);
			num = 0;
			memset(st, 0, 10);
			return 2;
		}
	}
	else if (ch == '.')
	{
		if (state == 2)
		{
			st[num] = '\0';
			Fenxi(state_left);
			num = 0;
			memset(st, 0, 10);
			return 11;
		}
		else if (state == 3)
			return 4;
		else if (state == 5)
			return 6;
		else if (state == 8 || state == 9)
			return 9;
		else if (state == 11)
		{
			st[num] = '\0';
			Fenxi(state_left);
			num = 0;
			memset(st, 0, 10);
			return 11;
		}
		else
		{
			key = 1;
			st[num] = ch;
			st[num + 1] = '\0';
			Fenxi(state_left);
			num = 0;
			memset(st, 0, 10);
			return 12;
		}
	}
	else if (ch == '\'')
	{
		if (state == 1)
			return 5;
		else if (state == 6)
			return 7;
		else if (state == 8 || state == 9)
			return 9;
		else if (state == 11)
		{
			st[num] = '\0';
			Fenxi(state_left);
			num = 0;
			memset(st, 0, 10);
			return 5;
		}
		else
		{
			key = 1;
			st[num] = ch;
			st[num + 1] = '\0';
			Fenxi(state_left);
			num = 0;
			memset(st, 0, 10);
			return 2;
		}
	}
	else if (ch == '\"')
	{
		if (state == 1)
			return 8;
		else if (state == 9)
			return 10;
		else if (state == 11)
		{
			st[num] = '\0';
			Fenxi(state_left);
			num = 0;
			memset(st, 0, 10);
			return 8;
		}
		else
		{
			key = 1;
			st[num] = ch;
			st[num + 1] = '\0';
			Fenxi(state_left);
			num = 0;
			memset(st, 0, 10);
			return 8;
		}
	}
	else
	{
		if (state == 1)
			return 11;
		else if (state == 5)
			return 6;
		else if (state == 8 || state == 9)
			return 9;
		else if ((state == 2) || (state == 3) || (state == 7) || (state == 10) || (state == 12))
		{
			st[num] = '\0';
			Fenxi(state_left);
			num = 0;
			memset(st, 0, 10);
			return 11;
		}
		else if (state == 11)
		{
			if ((num == 1) && (ch == '=') && ((st[0] == '>') || (st[0] == '<') || (st[0] == '=') || (st[0] == '+') || (st[0] == '-') || (st[0] == '*') || (st[0] == '/') || (st[0] == '!')))
				return 11;
			else if ((num == 1) && (ch == '+') && (st[0] == '+'))
				return 11;
			else if ((num == 1) && (ch == '-') && (st[0] == '-'))
				return 11;
			else if ((num == 1) && (ch == '&') && (st[0] == '&'))
				return 11;
			else if ((num == 1) && (ch == '|') && (st[0] == '|'))
				return 11;
			else
			{
				st[num] = '\0';
				Fenxi(state_left);
				num = 0;
				memset(st, 0, 10);
				return 11;
			}
		}
		else
		{
			key = 1;
			st[num] = ch;
			st[num + 1] = '\0';
			Fenxi(state_left);
			num = 0;
			memset(st, 0, 10);
			return 11;
		}
	}
}

//词法分析器
void saomiaoqi::Fenxi(int state_left)
{
	if (strcmp(st, "for") || (strcmp(st, "while")) || strcmp(st, "if"))
		key2 = 1;
	if (key == 1)
	{
		cout << "第" << hangshu << "行  " << st << "  错误" << endl;
		key = 0;
		num = 0;
		memset(st, 0, 10);
	}
	else
	{
		int i, n, m;
		switch (state_left)
		{
		case 2://关键字（标识符）
			for (i = 0; i < 32; ++i)
			{
				n = 1;
				if (strcmp(st, KT[i]) == 0)
				{
					token[ptr].number = i;
					token[ptr].content = st;
					token[ptr].type = "KT";
					ptr++;
					n = 0;
					break;
				}
			}
			if (n == 1)
			{
				if (IT[0] == NULL)
				{
					IT[0] = (char*)malloc(sizeof(st));
					strcpy(IT[0], st);
					token[ptr].number = 0;
					token[ptr].content = st;
					token[ptr].type = "IT";
					ptr++;
				}
				else
				{
					for (i = 0; i < sizeof(IT) / sizeof(*IT); ++i)
					{
						m = 1;
						if (IT[i] == NULL)
						{
							break;
						}
						if (strcmp(st, IT[i]) == 0)
						{
							token[ptr].number = i;
							token[ptr].content = st;
							token[ptr].type = "IT";
							ptr++;
							m = 0;
							break;
						}
					}
					if (m == 1)
					{
						IT[i] = (char*)malloc(sizeof(st));
						strcpy(IT[i], st);
						token[ptr].number = i;
						token[ptr].content = st;
						token[ptr].type = "IT";
						ptr++;
					}
				}
			}
			break;
		case 3://数字
			if (CT[0] == NULL)
			{
				CT[0] = (char*)malloc(sizeof(st));
				strcpy(CT[0], st);
				token[ptr].number = 0;
				token[ptr].content = st;
				token[ptr].type = "CT";
				ptr++;
			}
			else
			{
				for (i = 0; i < sizeof(CT) / sizeof(*CT); ++i)
				{
					m = 1;
					if (CT[i] == NULL)
					{
						break;
					}
					if (strcmp(st, CT[i]) == 0)
					{
						token[ptr].number = i;
						token[ptr].content = st;
						token[ptr].type = "CT";
						ptr++;
						m = 0;
						break;
					}
				}
				if (m == 1)
				{
					CT[i] = (char*)malloc(sizeof(st));
					strcpy(CT[i], st);
					token[ptr].number = i;
					token[ptr].content = st;
					token[ptr].type = "CT";
					ptr++;
				}
			}
			break;
		case 7://字符
			if (CTT[0] == NULL)
			{
				CTT[0] = (char*)malloc(sizeof(st));
				strcpy(CTT[0], st);
				token[ptr].number = 0;
				token[ptr].content = st;
				token[ptr].type = "CTT";
				ptr++;
			}
			else
			{
				for (i = 0; i < sizeof(CTT) / sizeof(*CTT); ++i)
				{
					m = 1;
					if (CTT[i] == NULL)
					{
						break;
					}
					if (strcmp(st, CTT[i]) == 0)
					{
						token[ptr].number = i;
						token[ptr].content = st;
						token[ptr].type = "CTT";
						ptr++;
						m = 0;
						break;
					}
				}
				if (m == 1)
				{
					CTT[i] = (char*)malloc(sizeof(st));
					strcpy(CTT[i], st);
					token[ptr].number = i;
					token[ptr].content = st;
					token[ptr].type = "CTT";
					ptr++;
				}
			}
			break;
		case 10://字符串
			if (ST[0] == NULL)
			{
				ST[0] = (char*)malloc(sizeof(st));
				strcpy(ST[0], st);
				token[ptr].number = 0;
				token[ptr].content = st;
				token[ptr].type = "ST";
				ptr++;
			}
			else
			{
				for (i = 0; i < sizeof(ST) / sizeof(*ST); ++i)
				{
					m = 1;
					if (ST[i] == NULL)
					{
						break;
					}
					if (strcmp(st, ST[i]) == 0)
					{
						token[ptr].number = i;
						token[ptr].content = st;
						token[ptr].type = "ST";
						ptr++;
						m = 0;
						break;
					}
				}
				if (m == 1)
				{
					ST[i] = (char*)malloc(sizeof(st));
					strcpy(ST[i], st);
					token[ptr].number = i;
					token[ptr].content = st;
					token[ptr].type = "ST";
					ptr++;
				}
			}
			break;
		case 11://界符
			for (i = 0; i < 31; ++i)
			{
				if (strcmp(st, PT[i]) == 0)
				{
					token[ptr].number = i;
					token[ptr].content = st;
					token[ptr].type = "PT";
					ptr++;
					break;
				}
			}
			break;
		case 12://数字
			if (XT[0] == NULL)
			{
				XT[0] = (char*)malloc(sizeof(st));
				strcpy(XT[0], st);
				token[ptr].number = 0;
				token[ptr].content = st;
				token[ptr].type = "XT";
				ptr++;
			}
			else
			{
				for (i = 0; i < sizeof(XT) / sizeof(*XT); ++i)
				{
					m = 1;
					if (XT[i] == NULL)
					{
						break;
					}
					if (strcmp(st, XT[i]) == 0)
					{
						token[ptr].number = i;
						token[ptr].content = st;
						token[ptr].type = "XT";
						ptr++;
						m = 0;
						break;
					}
				}
				if (m == 1)
				{
					XT[i] = (char*)malloc(sizeof(st));
					strcpy(XT[i], st);
					token[ptr].number = i;
					token[ptr].content = st;
					token[ptr].type = "XT";
					ptr++;
				}
			}
			break;
		default:
		{
			cout << "第" << hangshu << "行  " << st << "  错误" << endl;
			key = 0;
			num = 0;
			memset(st, 0, 10);
		}
		}
	}
}

void saomiaoqi::kongzhi()
{
	char ch;
	state = 1;//初始状态
	num = 0;
	FILE* fp;
	if ((fp = fopen("C.txt", "r+")) == NULL)
	{
		cout << "cann't open C.txt" << endl;
		exit(1);
	}
	while ((ch = fgetc(fp)))
	{
		state_left = state;
		state = Change_State(state, ch);
		if (state != 0)
		{
			st[num++] = ch;
		}
		else
		{
			st[num] = '\0';
			if (state_left != 1)
				Fenxi(state_left);
			memset(st, 0, 10);
			num = 0;
			state = 1;
		}
		if (ch == '#')
			break;
	}
}

int G_anl()
{
	string t;
	int i = 0;
	ss.push("#");
	ss.push("P");
	while (!((ss.top() == "#") && (i == ptr)))
	{
		t = ss.top();
		if ((t == "P") && (token[i].content == "int"))
		{
			ss.pop();
			ss.push("}");
			ss.push("A");
			ss.push("{");
			ss.push(")");
			ss.push("(");
			ss.push("main");
			ss.push("int");
		}
		else if ((t == "A") && ((token[i].content == "int") || (token[i].content == "char")))
		{
			ss.pop();
			ss.push("M");
			ss.push("I");
		}
		else if ((t == "I") && ((token[i].content == "int") || (token[i].content == "char")))
		{
			ss.pop();
			ss.push("I");
			ss.push("w0");
			ss.push("B");
			ss.push("b");
			ss.push("t");
		}
		else if ((t == "I") && ((token[i].type == "IT") || (token[i].content == "scanf") || (token[i].content == "printf") || (token[i].content == "if") || (token[i].content == "while") || (token[i].content == "return"))) { ss.pop(); }
		else if ((t == "B") && (token[i].content == "="))
		{
			ss.pop();
			ss.push("B");
			ss.push("D");
			ss.push("w1");
		}
		else if ((t == "B") && (token[i].content == ","))
		{
			ss.pop();
			ss.push("B");
			ss.push("b");
			ss.push("w2");
		}
		else if ((t == "B") && (token[i].content == ";")) { ss.pop(); }
		else if ((t == "D") && ((token[i].type == "CT") || (token[i].type == "XT") || (token[i].type == "IT") || (token[i].content == "(")))
		{
			ss.pop();
			ss.push("E");
		}
		else if ((t == "D" && (token[i].type == "CTT")))
		{
			ss.pop();
			ss.push("ch");
		}
		else if ((t == "M") && ((token[i].type == "IT") || (token[i].content == "scanf") || (token[i].content == "printf") || (token[i].content == "if") || (token[i].content == "while") || (token[i].content == "return")))
		{
			ss.pop();
			ss.push("R");
			ss.push("Y");
		}
		else if ((t == "Y") && (token[i].type == "IT"))
		{
			ss.pop();
			ss.push("Y");
			ss.push("Eq");
		}
		else if ((t == "Y") && (token[i].content == "if"))
		{
			ss.pop();
			ss.push("Y");
			ss.push("If");
		}
		else if ((t == "Y") && (token[i].content == "while"))
		{
			ss.pop();
			ss.push("Y");
			ss.push("While");
		}
		else if ((t == "Y") && (token[i].content == "scanf"))
		{
			ss.pop();
			ss.push("Y");
			ss.push("Scf");
		}
		else if ((t == "Y") && (token[i].content == "printf"))
		{
			ss.pop();
			ss.push("Y");
			ss.push("Ptf");
		}
		else if ((t == "Y") && ((token[i].content == "return") || (token[i].content == "}"))) { ss.pop(); }
		else if ((t == "If") && (token[i].content == "if"))
		{
			ss.pop();
			ss.push("Ei");
			ss.push("}");
			ss.push("Y");
			ss.push("{");
			ss.push("L");
			ss.push("if");
		}
		else if ((t == "Ei") && (token[i].content == "else"))
		{
			ss.pop();
			ss.push("Ei");
			ss.push("}");
			ss.push("Y");
			ss.push("{");
			ss.push("El");
			ss.push("else");
		}
		else if ((t == "Ei") && ((token[i].type == "IT") || (token[i].content == "if") || (token[i].content == "while") || (token[i].content == "return") || (token[i].content == "}"))) { ss.pop(); }
		else if ((t == "El") && (token[i].content == "if"))
		{
			ss.pop();
			ss.push("L");
			ss.push("if");
		}
		else if ((t == "El") && (token[i].content == "{")) { ss.pop(); }
		else if ((t == "While") && (token[i].content == "while"))
		{
			ss.pop();
			ss.push("}");
			ss.push("Y");
			ss.push("{");
			ss.push("L");
			ss.push("while");
		}
		else if ((t == "R") && (token[i].content == "return"))
		{
			ss.pop();
			ss.push("w0");
			ss.push("0");
			ss.push("r");
		}
		else if ((t == "Eq") && (token[i].type == "IT"))
		{
			ss.pop();
			ss.push("w0");
			ss.push("E");
			ss.push("w1");
			ss.push("b");
		}
		else if ((t == "E") && ((token[i].type == "CT") || (token[i].type == "XT") || (token[i].type == "IT") || (token[i].content == "(")))
		{
			ss.pop();
			ss.push("E'");
			ss.push("T");
		}
		else if ((t == "E'") && ((token[i].content == "+") || (token[i].content == "-")))
		{
			ss.pop();
			ss.push("E'");
			ss.push("T");
			ss.push("w3");
		}
		else if ((t == "E'") && ((token[i].content == ")") || (token[i].content == ",") || (token[i].content == ";") || (token[i].content == ">") || (token[i].content == "<"))) { ss.pop(); }
		else if ((t == "T") && ((token[i].type == "CT") || (token[i].type == "XT") || (token[i].type == "IT") || (token[i].content == "(")))
		{
			ss.pop();
			ss.push("T'");
			ss.push("F");
		}
		else if ((t == "T") && ((token[i].content == "+") || (token[i].content == "-") || (token[i].content == ")"))) { ss.pop(); }
		else if ((t == "T'") && ((token[i].content == "*") || (token[i].content == "/")))
		{
			ss.pop();
			ss.push("T'");
			ss.push("F");
			ss.push("w4");
		}
		else if ((t == "T'") && ((token[i].content == "+") || (token[i].content == "-") || (token[i].content == ",") || (token[i].content == ")") || (token[i].content == ";") || (token[i].content == ">") || (token[i].content == "<"))) { ss.pop(); }
		else if ((t == "F") && ((token[i].type == "CT") || (token[i].type == "XT") || (token[i].type == "IT")))
		{
			i++;
			ss.pop();
		}
		else if ((t == "F") && (token[i].content == "("))
		{
			ss.pop();
			ss.push(")");
			ss.push("E");
			i++;
		}
		else if ((t == "L") && (token[i].content == "("))
		{
			ss.pop();
			ss.push(")");
			ss.push("E");
			ss.push("w5");
			ss.push("E");
			ss.push("(");
		}
		else if ((t == "int") && (token[i].content == "int"))
		{
			i++; ss.pop();
		}
		else if ((t == "main") && (token[i].content == "main"))
		{
			i++; ss.pop();
		}
		else if ((t == "(") && (token[i].content == "("))
		{
			i++; ss.pop();
		}
		else if ((t == ")") && (token[i].content == ")"))
		{
			i++; ss.pop();
		}
		else if ((t == "{") && (token[i].content == "{"))
		{
			i++; ss.pop();
		}
		else if ((t == "}") && (token[i].content != "#"))
		{
			i++; ss.pop();
		}
		else if ((t == "t") && ((token[i].content == "int") || (token[i].content == "char")))
		{
			i++; ss.pop();
		}
		else if ((t == "b") && (token[i].type == "IT"))
		{
			i++; ss.pop();
		}
		else if ((t == "st") && (token[i].type == "ST"))
		{
			i++; ss.pop();
		}
		else if ((t == "ch") && (token[i].type == "CTT"))
		{
			i++; ss.pop();
		}
		else if ((t == ",") && (token[i].content == ","))
		{
			i++; ss.pop();
		}
		else if ((t == "&") && (token[i].type == "&"))
		{
			i++; ss.pop();
		}
		else if ((t == "w0") && (token[i].content == ";"))
		{
			i++; ss.pop();
		}
		else if ((t == "w1") && (token[i].content == "=") && (token[i - 1].type == "IT"))
		{
			i++; ss.pop();
		}
		else if ((t == "w2") && (token[i].content == ","))
		{
			i++; ss.pop();
		}
		else if ((t == "w3") && ((token[i].content == "+") || (token[i].content == "-")))
		{
			i++; ss.pop();
		}
		else if ((t == "w4") && ((token[i].content == "*") || (token[i].content == "/")))
		{
			i++; ss.pop();
		}
		else if ((t == "w5") && ((token[i].content == "<") || (token[i].content == ">")))
		{
			i++; ss.pop();
		}
		else if ((t == "w6") && ((token[i].content == "&&") || (token[i].content == "||")))
		{
			i++; ss.pop();
		}
		else if ((t == "r") && (token[i].content == "return"))
		{
			i++; ss.pop();
		}
		else if ((t == "0") && (token[i].content == "0"))
		{
			i++; ss.pop();
		}
		else if ((t == "if") && (token[i].content == "if"))
		{
			i++; ss.pop();
		}
		else if ((t == "else") && (token[i].content == "else"))
		{
			i++; ss.pop();
		}
		else if ((t == "while") && (token[i].content == "while"))
		{
			i++; ss.pop();
		}
		else
		{
			return 0;
		}
	}
	return 1;
}

typedef struct SYNBL//符号表总表
{
	string name, cat;
	char* type;
	string* addr;
};

typedef struct TYPEL//类型表
{
	char tval;
	int* tpoint;
};

float CONSL[1000];//常数表
int c_t = 0;
int l_t = 0; int v_t = 0;


int check_s(SYNBL* S, string s, int top)//查总表，有这个元素返回1，否则返回0
{
	int r = 0;
	for (int i = 0; i < top; i++)
	{
		if (S[i].name == s)
		{
			r = 1;
			break;
		}
	}
	return r;
}

template <class Type>
Type stringToNum(const string& str)
{
	istringstream iss(str);
	Type num;
	iss >> num;
	return num;
}

SYNBL sl[100]; int s_t = 0;//_t指示表顶端
TYPEL tl[3] = { {'i',NULL},{'f',NULL},{'c',NULL} };

void create_sybl()
{
	int i = 0;
	while (i < ptr)
	{
		if (token[i].type == "IT")
		{
			if (token[i - 1].type != "KT")//已定义或未定义即使用
			{
				if (!check_s(sl, token[i].content, s_t))//未定义即使用
				{
					cout << token[i].content << "未定义" << endl;
				}
				i++;
			}
			else if ((token[i + 1].content == "=") && (token[i + 2].type == "CT"))//常数
			{
				if (token[i - 1].content == "int")
				{
					CONSL[c_t] = stringToNum<int>(token[i + 2].content);
					sl[s_t].type = &tl[0].tval;
				}
				else if (token[i - 1].content == "float")
				{
					CONSL[c_t] = stringToNum<float>(token[i].content);
					sl[s_t].type = &tl[1].tval;
				}
				sl[s_t].name = token[i].content;
				sl[s_t].cat = 'c';
				c_t++; s_t++; i++;
			}
			else
			{
				if (token[i - 1].content == "int") sl[s_t].type = &tl[0].tval;
				else if (token[i - 1].content == "float") sl[s_t].type = &tl[1].tval;
				else if (token[i - 1].content == "char") sl[s_t].type = &tl[2].tval;
				sl[s_t].name = token[i].content;
				sl[s_t].cat = 'v';
				i++; s_t++;
			}
		}
		else i++;
	}
}

Token t_c[100][100];
int tail[100];//句子长度
int t_c_num = 0;//句子个数
Four_exp F[1000];
int F_top = 0;
int pre_loc = 0;
int sign = 0;
int pre_t = 0;
int Four_num = 0;//四元式序号

void cut()//将Token序列以分号隔开，切割成句子
{
	int i = 0, j = 0, k = 0;
	while (i < ptr)
	{
		if (token[i].content == ";")
		{
			tail[t_c_num]++; i++; j++; k = 0; t_c_num++;
		}
		else
		{
			t_c[j][k].content = token[i].content;
			t_c[j][k].number = token[i].number;
			t_c[j][k].type = token[i].type;
			tail[t_c_num]++; i++; k++;
		}
	}
}

int IT_num(Token* t, int head, int tail)//标识符或常数数量
{
	int num = 0;
	for (int i = head; i <= tail; i++)
	{
		if ((t[i].type == "IT") || (t[i].type == "CT")) num++;
	}
	return num;
}

int search_equ(Token* t, int head, int tail, int& location)//查找等号
{
	int re = 0;
	for (int i = head; i <= tail; i++)
	{
		if (t[i].content == "=")
		{
			location = i;
			re = 1;
			break;
		}
	}
	return re;
}

void search_cal(Token* t, int head, int tail, int& location)//查找算术运算符
{
	for (int i = head; i <= tail; i++)
	{
		if ((t[i].content == "*") || (t[i].content == "/") || (t[i].content == "+") || (t[i].content == "-"))
		{
			location = i;
			break;
		}
	}
}

string Int_to_String(int n)//int转string

{
	ostringstream stream;
	stream << n; //n为int类型
	return stream.str();
}

void create_cal(Token* t, int head, int tail, string result)//算术表达式四元式
{
	search_cal(t, head, tail, pre_loc);
	F[F_top].syb = t[pre_loc].content;
	F[F_top].exp1 = t[pre_loc - 1].content;
	F[F_top].exp2 = t[pre_loc + 1].content;
	F[F_top].res = result;
	F_top++;
}

void create_equ(Token* t)//赋值语句四元式
{
	search_equ(t, 0, tail[pre_t], pre_loc);
	F[F_top].syb = "=";
	F[F_top].exp2 = " ";
	F[F_top].res = t[pre_loc - 1].content;
	if (IT_num(t, pre_loc + 1, tail[pre_t] - 1) == 1)
	{
		F[F_top].exp1 = t[pre_loc + 1].content;
		F_top++;
	}
	else
	{
		F[F_top].exp1 = "t" + Int_to_String(Four_num);
		F_top++; Four_num++;
		create_cal(t, pre_loc + 1, tail[pre_t] - 1, F[F_top - 1].exp1);
	}
}

void create_log(Token* t)//逻辑表达式四元式
{
	F[F_top].syb = t[3].content;//if while语句
	F[F_top].exp1 = t[2].content;//if while语句
	F[F_top].res = "t" + Int_to_String(Four_num);
	Four_num++;
	if (t[5].content == ")")//if while语句
	{
		F[F_top].exp2 = t[4].content;
		F_top++;
	}
	else
	{
		F[F_top].exp2 = "t" + Int_to_String(Four_num);
		F_top++; Four_num++;
		create_cal(t, 4, 6, F[F_top - 1].exp2);//if while语句
	}
}

void create_if(Token* t)//if语句四元式
{
	int t_if = F_top, t_else;
	create_log(t);
	F[F_top].syb = "if";
	F[F_top].exp1 = F[t_if].res;
	F[F_top].exp2 = " ";
	F_top++;
	create_equ(t);
	if (t_c[pre_t + 1][1].content == "else")
	{
		sign = 1;
		F[F_top - 1].res = "F" + Int_to_String(F_top + 1);
		F[F_top].syb = "else";
		F[F_top].exp1 = F[F_top].exp2 = " ";
		t_else = F_top;
		F_top++;
		create_equ(t);
	}
	F[t_if].res = "F" + Int_to_String(F_top);
	F[F_top].syb = "ie";
	F[F_top].exp1 = F[F_top].exp2 = F[F_top].res = " ";
	if (sign == 1)
	{
		F[t_else].res = "F" + Int_to_String(F_top);
		sign = 0;
	}
	F_top++;
}

void create_while(Token* t)//while语句四元式
{
	F[F_top].syb = "while";
	F[F_top].exp1 = F[F_top].exp2 = F[F_top].res = " ";
	F_top++;
	int t_we = F_top;
	create_log(t);
	int t_do = F_top;
	F[F_top].syb = "do";
	F[F_top].exp1 = F[t_we].res;
	F[F_top].exp2 = " ";
	F_top++;
	create_equ(t);
	F[t_do].res = "F" + Int_to_String(F_top + 1);
	F[F_top].syb = "we";
	F[F_top].exp1 = F[F_top].exp2 = " ";
	F[F_top].res = "F" + Int_to_String(t_we);
	F_top++;
}

void create_Four()
{
	for (pre_t = 0; pre_t < t_c_num; pre_t++)
	{
		if (t_c[pre_t][0].content == "if") create_if(t_c[pre_t]);
		else if (t_c[pre_t][0].content == "while") create_while(t_c[pre_t]);
		else if (search_equ(t_c[pre_t], 0, tail[pre_t], pre_loc)) create_equ(t_c[pre_t]);
	}
}

bool is_number(string s)
{
	try
	{
		stof(s);
	}
	catch (std::invalid_argument&)
	{
		return 0;
	}
	return 1;
}

typedef struct mubiaodaima
{
	string zhiling;
	string num1, num2;
}mubiaodaima;

vector <mubiaodaima> obj;//目标代码生成区
int obj_x = 0;//下标
class Mubiao
{
public:
	Mubiao() {}
	~Mubiao() {}
	int code(mubiaodaima* d, int num);//把目标代码送入目标代码区
	int back(int pi, int pk);//(返填函数)把地址 pk 返填到地址 pi中
	nd* getK();//取下一基本块
	void get_jibenkuai(nd* jibenkuai) { k = jibenkuai; }
	int getH(vector<Four_exp>yuju);//生成活跃信息
	void kongzhi(nd* temp);//控制函数
	int _symbol(string x);
private:
	string qt[1000][7];//四元式区(附有变量的活跃信息)
	nd* k;//当前基本块链结
	stack<int> sem;//语义栈
	string symbl[1000][2];//符号表
	int symbl_x = 0;//当前符号表的数量
	string rdl = "0";//寄存器描述 =0空闲,=x表示被x占用
	string rdl_H = "0";//rdl中被占用标识符的活跃信息
};
int Mubiao::code(mubiaodaima* d, int num)
{
	for (int i = 0; i < num; i++)
		obj.push_back(d[i]);
	return 1;
}

int Mubiao::back(int pi, int pk)
{
	string s1 = Int_to_String(pk);
	obj[pi].num2 = s1;
	return 1;
}

nd* Mubiao::getK()//取下一个基本块
{
	k = k->next;
	return k;
}

int Mubiao::_symbol(string x)
{
	int m;
	if (symbl_x == 0)
	{
		symbl[0][0] = x;
		if (x[0] != 'T')
			symbl[0][1] = "Y";
		else
			symbl[0][1] = "N";
		return 0;
	}
	else
	{
		int i;
		for (i = 0; i < symbl_x; i++)
		{
			m = 1;
			if (symbl[i][0] == x)
			{
				m = 0;
				break;
			}
		}
		if (m == 1)
		{
			symbl[i][0] = x;
			if (x[0] != 'T')
				symbl[i][1] = "Y";
			else
				symbl[i][1] = "N";
		}
		return i;
	}
}

int Mubiao::getH(vector<Four_exp>yuju)
{
	int sz = yuju.size();
	int pos;
	for (int i = sz - 1; i >= 0; i--)
	{
		qt[i][0] = yuju[i].syb;
		qt[i][1] = yuju[i].exp1;
		qt[i][3] = yuju[i].exp2;
		qt[i][5] = yuju[i].res;
		pos = _symbol(yuju[i].res);
		qt[i][6] = symbl[pos][1];
		symbl[pos][1] = "N";
		if (is_number(yuju[i].exp2))
			qt[i][4] = "C";
		else
		{
			pos = _symbol(yuju[i].exp2);
			qt[i][4] = symbl[pos][1];
			symbl[pos][1] = "Y";
		}
		if (is_number(yuju[i].exp1))
			qt[i][2] = "C";
		else
		{
			pos = _symbol(yuju[i].exp1);
			qt[i][2] = symbl[pos][1];
			symbl[pos][1] = "Y";
		}
	}
	return 1;
}
void Mubiao::kongzhi(nd* temp)
{
	k = temp;
	while ((temp = getK()) != NULL)
	{
		int i = 0;
		int length = temp->blk.size();
		getH(temp->blk);
		while (i < length)
		{
			if (qt[i][0] == "if")
			{
				if (rdl == "0")
				{
					mubiaodaima daima[2];
					daima[0].zhiling = "LD";
					daima[0].num1 = "RDL";
					daima[0].num2 = qt[i][1];
					daima[1].zhiling = "FJ";
					daima[1].num1 = "RDL";
					code(daima, 2);
					obj_x += 2;
					sem.push(obj_x - 1);
				}
				else if (rdl == qt[i][1])
				{
					if (qt[i][2] == "Y")
					{
						mubiaodaima daima[2];
						daima[0].zhiling = "ST";
						daima[0].num1 = "RDL";
						daima[0].num2 = qt[i][1];
						daima[1].zhiling = "FJ";
						daima[1].num1 = "RDL";
						code(daima, 2);
						obj_x += 2;
					}
					else
					{
						mubiaodaima daima[1];
						daima[0].zhiling = "FJ";
						daima[0].num1 = "RDL";
						code(daima, 1);
						obj_x += 1;
					}
					sem.push(obj_x - 1);
					rdl == "0";
					rdl_H == "0";
				}
				else
				{
					if (rdl_H == "Y")
					{
						mubiaodaima daima[3];
						daima[0].zhiling = "ST";
						daima[0].num1 = "R";
						daima[0].num2 = rdl;
						daima[1].zhiling = "LD";
						daima[1].num1 = "R";
						daima[1].num2 = qt[0][1];
						daima[2].zhiling = "FJ";
						daima[2].num1 = "R";
						code(daima, 3);
						obj_x += 3;
					}
					else
					{
						mubiaodaima daima[2];
						daima[0].zhiling = "LD";
						daima[0].num1 = "R";
						daima[0].num2 = qt[0][1];
						daima[1].zhiling = "FJ";
						daima[1].num1 = "R";
						code(daima, 2);
						obj_x += 2;
					}
					sem.push(obj_x - 1);
					rdl == "0";
					rdl_H == "0";
				}
			}
			else if (qt[i][0] == "else")
			{
				if (rdl != "0" && rdl_H == "Y")
				{
					mubiaodaima daima[1];
					daima[0].zhiling = "ST";
					daima[0].num1 = "RDL";
					daima[0].num2 = rdl;
					code(daima, 1);
					obj_x += 1;
				}
				back(sem.top(), obj_x + 2);
				sem.pop();
				mubiaodaima daim[1];
				daim[0].zhiling = "JMP";
				code(daim, 1);
				obj_x += 1;
				sem.push(obj_x - 1);
			}
			else if (qt[i][0] == "ie")
			{
				if (rdl != "0" && rdl_H == "Y")
				{
					mubiaodaima daima[1];
					daima[0].zhiling = "ST";
					daima[0].num1 = "RDL";
					daima[0].num2 = rdl;
					code(daima, 1);
					obj_x += 1;
				}
				back(sem.top(), obj_x);
				sem.pop();
			}
			else if (qt[i][0] == "while")
			{
				//sem.push(obj_x + 1);
			}
			else if (qt[i][0] == "do")
			{
				sem.push(obj_x - 1);
				if (rdl == "0")
				{
					mubiaodaima daima[2];
					daima[0].zhiling = "LD";
					daima[0].num1 = "RDL";
					daima[0].num2 = qt[i][1];
					daima[1].zhiling = "FJ";
					daima[1].num1 = "RDL";
					code(daima, 2);
					obj_x += 2;
				}
				else if (rdl == qt[i][1])
				{
					if (qt[i][2] == "Y")
					{
						mubiaodaima daima[2];
						daima[0].zhiling = "ST";
						daima[0].num1 = "RDL";
						daima[0].num2 = qt[i][1];
						daima[1].zhiling = "FJ";
						daima[1].num1 = "RDL";
						code(daima, 2);
						obj_x += 2;
					}
					else
					{
						mubiaodaima daima[1];
						daima[0].zhiling = "FJ";
						daima[0].num1 = "RDL";
						code(daima, 1);
						obj_x += 1;
					}
					rdl = "0";
					rdl_H = "0";
				}
				else
				{
					if (rdl_H == "Y")
					{
						mubiaodaima daima[3];
						daima[0].zhiling = "ST";
						daima[0].num1 = "RDL";
						daima[0].num2 = rdl;
						daima[1].zhiling = "LD";
						daima[1].num1 = "RDL";
						daima[1].num2 = qt[i][1];
						daima[2].zhiling = "FJ";
						daima[2].num1 = "RDL";
						code(daima, 3);
						obj_x += 3;
					}
					else
					{
						mubiaodaima daima[2];
						daima[0].zhiling = "LD";
						daima[0].num1 = "RDL";
						daima[0].num2 = qt[i][1];
						daima[1].zhiling = "FJ";
						daima[1].num1 = "RDL";
						code(daima, 2);
						obj_x += 2;
					}
					rdl = "0";
					rdl_H = "0";
				}
				sem.push(obj_x - 1);
			}
			else if (qt[i][0] == "we")
			{
				if (rdl != "0" && rdl_H == "Y")
				{
					mubiaodaima daima[1];
					daima[0].zhiling = "ST";
					daima[0].num1 = "RDL";
					daima[0].num2 = rdl;
					code(daima, 1);
					obj_x += 1;
				}
				rdl = qt[i][5];
				rdl_H = qt[i][6];
				back(sem.top(), obj_x + 2);
				sem.pop();
				mubiaodaima daim[1];
				daim[0].zhiling = "JMP";
				string s1 = Int_to_String(sem.top());
				daim[0].num2 = s1;
				sem.pop();
				code(daim, 1);
				obj_x += 1;
			}
			else if (qt[i][0] == "=")
			{
				if (rdl == "0")
				{
					mubiaodaima daima[1];
					daima[0].zhiling = "LD";
					daima[0].num1 = "RDL";
					daima[0].num2 = qt[i][1];
					code(daima, 1);
					obj_x += 1;
				}
				else if (rdl == qt[i][1])
				{
					if (qt[i][2] == "Y")
					{
						mubiaodaima daima[1];
						daima[0].zhiling = "ST";
						daima[0].num1 = "RDL";
						daima[0].num2 = qt[i][1];
						code(daima, 1);
						obj_x += 1;
					}
				}
				else
				{
					if (rdl_H == "Y")
					{
						mubiaodaima daima[2];
						daima[0].zhiling = "ST";
						daima[0].num1 = "RDL";
						daima[0].num2 = rdl;
						daima[1].zhiling = "LD";
						daima[1].num1 = "RDL";
						daima[1].num2 = qt[i][1];
						code(daima, 2);
						obj_x += 2;
					}
					else
					{
						mubiaodaima daima[1];
						daima[0].zhiling = "LD";
						daima[0].num1 = "RDL";
						daima[0].num2 = qt[i][1];
						code(daima, 1);
						obj_x += 1;
					}
				}
				rdl = qt[i][5];
				rdl_H = qt[i][6];
			}
			else
			{
				if (rdl == "0")
				{
					mubiaodaima daima[2];
					daima[0].zhiling = "LD";
					daima[0].num1 = "RDL";
					daima[0].num2 = qt[i][1];
					daima[1].zhiling = qt[i][0];
					daima[1].num1 = "RDL";
					daima[1].num2 = qt[i][3];
					code(daima, 2);
					obj_x += 2;
				}
				else if (rdl == qt[i][1])
				{
					if (qt[i][2] == "Y")
					{
						mubiaodaima daima[2];
						daima[0].zhiling = "ST";
						daima[0].num1 = "RDL";
						daima[0].num2 = qt[i][1];
						daima[1].zhiling = qt[i][0];
						daima[1].num1 = "RDL";
						daima[1].num2 = qt[i][3];
						code(daima, 2);
						obj_x += 2;
					}
					else
					{
						mubiaodaima daima[1];
						daima[0].zhiling = qt[i][0];
						daima[0].num1 = "RDL";
						daima[0].num2 = qt[i][3];
						code(daima, 1);
						obj_x += 1;
					}
				}
				else if ((rdl == qt[i][3]) && (qt[i][3] == "+" || qt[i][3] == "-" || qt[i][3] == "*"))
				{
					if (qt[i][4] == "Y")
					{
						mubiaodaima daima[2];
						daima[0].zhiling = "ST";
						daima[0].num1 = "RDL";
						daima[0].num2 = qt[i][3];
						daima[1].zhiling = qt[i][0];
						daima[1].num1 = "RDL";
						daima[1].num2 = qt[i][1];
						code(daima, 2);
						obj_x += 2;
					}
					else
					{
						mubiaodaima daima[1];
						daima[0].zhiling = qt[i][0];
						daima[0].num1 = "RDL";
						daima[0].num2 = qt[i][1];
						code(daima, 1);
						obj_x += 1;
					}
				}
				else
				{
					if (rdl_H == "Y")
					{
						mubiaodaima daima[3];
						daima[0].zhiling = "ST";
						daima[0].num1 = "RDL";
						daima[0].num2 = rdl;
						daima[1].zhiling = "LD";
						daima[1].num1 = "RDL";
						daima[1].num2 = qt[i][1];
						daima[2].zhiling = qt[i][0];
						daima[2].num1 = "RDL";
						daima[2].num2 = qt[i][3];
						code(daima, 3);
						obj_x += 3;
					}
					else
					{
						mubiaodaima daima[2];
						daima[0].zhiling = "LD";
						daima[0].num1 = "RDL";
						daima[0].num2 = qt[i][1];
						daima[1].zhiling = qt[i][0];
						daima[1].num1 = "RDL";
						daima[1].num2 = qt[i][3];
						code(daima, 2);
						obj_x += 2;
					}
				}
				rdl = qt[i][5];
				rdl_H = qt[i][6];
			}
			i++;
		}
	}
}

int main()
{
	saomiaoqi C;
	C.kongzhi();
	cout << "token序列如下：" << endl;
	for (int i = 0; i < ptr; i++)
	{
		cout << "<" << token[i].type << "," << token[i].number << "," << token[i].content << ">" << " ";
	}
	cout << endl;
	cout << "语法分析结果：";
	if (G_anl())
		cout << "正确" << endl;
	else
		cout << "错误" << endl;
	create_sybl();
	cout << "符号表总表如下：" << endl;
	for (int j = 0; j < s_t; j++)
	{
		cout << sl[j].name << " " << *sl[j].type << "tp " << sl[j].cat << endl;
	}
	cout << "常数表如下：" << endl;
	for (int i = 0; i < c_t; i++)
		cout << CONSL[i] << endl;
	cut();
	create_Four();
	cout << "四元式序列如下：" << endl;
	for (int i = 0; i < F_top; i++) cout << "( " << F[i].syb << " , " << F[i].exp1 << " , " << F[i].exp2 << " , " << F[i].res << " )" << endl;

	DAG_graph DAG;
	Four_exp a;
	int f = 0;
	for (int i = 0; i < F_top; i++)
	{
		a = F[i];
	}
	jibenkuai x;
	x.create(F, F_top);
	nd* flag = x.get_head();
	while (flag->next != NULL)
	{
		f = 0;
		flag = flag->next;
		DAG.clear();
		for (int i = 0; i < flag->blk.size(); i++)
		{

			if (flag->blk[i].syb[0] >= 'a' && flag->blk[i].syb[0] <= 'z')
			{
				a = flag->blk[i];
				f = 1;
			}
			else
				DAG.operate(flag->blk[i]);
		}
		DAG.print();
		flag->blk = block;
		if (f)
			flag->blk.push_back(a);
	}
	cout << "优化已完成" << endl;
	Mubiao m;
	m.kongzhi(x.get_head());
	for (int i = 0; i < obj.size(); i++)
	{
		cout << i + 1 << " " << obj[i].zhiling << " " << obj[i].num1 << " " << obj[i].num2 << endl;
	}
	system("pause");
	return 0;
}
```

